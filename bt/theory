A Smart Contract (or cryptocontract) is a computer program that directly and automatically controls the transfer of digital assets between the parties under certain conditions. A smart contract works in the same way as a traditional contract while also automatically enforcing the contract. Smart contracts are programs that execute exactly as they are set up(coded, programmed) by their creators. Just like a traditional contract is enforceable by law, smart contracts are enforceable by code.

The bitcoin network was the first to use some sort of smart contract by using them to transfer value from one person to another.
The smart contract involved employs basic conditions like checking if the amount of value to transfer is actually available in the sender account.
Later, the Ethereum platform emerged which was considered more powerful, precisely because the developers/programmers could make custom contracts in a Turing-complete language.
It is to be noted that the contracts written in the case of the bitcoin network were written in a Turing-incomplete language, restricting the potential of smart contracts implementation in the bitcoin network.
There are some common smart contract platforms like Ethereum, Solana, Polkadot, Hyperledger fabric, etc.
History:

In 1994, Nick Szabo, a legal scholar, and a cryptographer recognized the application of a decentralized ledger for smart contracts. He theorized that these contracts could be written in code which can be stored and replicated on the system and supervised by the network of computers that constitute the blockchain. These smart contracts could also help in transferring digital assets between the parties under certain conditions.

Features of Smart Contracts
The following are some essential characteristics of a smart contract:

Distributed: Everyone on the network is guaranteed to have a copy of all the conditions of the smart contract and they cannot be changed by one of the parties. A smart contract is replicated and distributed by all the nodes connected to the network.
Deterministic: Smart contracts can only perform functions for which they are designed only when the required conditions are met. The final outcome will not vary, no matter who executes the smart contract.
Immutable: Once deployed smart contract cannot be changed, it can only be removed as long as the functionality is implemented previously.
Autonomy: There is no third party involved. The contract is made by you and shared between the parties. No intermediaries are involved which minimizes bullying and grants full authority to the dealing parties. Also, the smart contract is maintained and executed by all the nodes on the network, thus removing all the controlling power from any one party’s hand.
Customizable: Smart contracts have the ability for modification or we can say customization before being launched to do what the user wants it to do.
Transparent: Smart contracts are always stored on a public distributed ledger called blockchain due to which the code is visible to everyone, whether or not they are participants in the smart contract.
Trustless: These are not required by third parties to verify the integrity of the process or to check whether the required conditions are met.
Self-verifying: These are self-verifying due to automated possibilities.
Self-enforcing: These are self-enforcing when the conditions and rules are met at all stages.
Capabilities of Smart Contracts
Accuracy: Smart contracts are accurate to the limit a programmer has accurately coded them for execution.
Automation: Smart contracts can automate the tasks/ processes that are done manually.
Speed: Smart contracts use software code to automate tasks, thereby reducing the time it takes to maneuver through all the human interaction-related processes. Because everything is coded, the time taken to do all the work is the time taken for the code in the smart contract to execute.
Backup: Every node in the blockchain maintains the shared ledger, providing probably the best backup facility.
Security: Cryptography can make sure that the assets are safe and sound. Even if someone breaks the encryption, the hacker will have to modify all the blocks that come after the block which has been modified. Please note that this is a highly difficult and computation-intensive task and is practically impossible for a small or medium-sized organization to do.
Savings: Smart contracts save money as they eliminate the presence of intermediaries in the process. Also, the money spent on the paperwork is minimal to zero.
Manages information: Smart contract manages users’ agreement, and stores information about an application like domain registration, membership records, etc.
Multi-signature accounts: Smart contracts support multi-signature accounts to distribute funds as soon as all the parties involved confirm the agreement.
How Do Smart Contracts Work?
A smart contract is just a digital contract with the security coding of the blockchain.

It has details and permissions written in code that require an exact sequence of events to take place to trigger the agreement of the terms mentioned in the smart contract.
It can also include the time constraints that can introduce deadlines in the contract.
Every smart contract has its address in the blockchain. The contract can be interacted with by using its address presuming the contract has been broadcasted on the network.
The idea behind smart contracts is pretty simple. They are executed on a basis of simple logic, IF-THEN for example:

IF you send object A, THEN the sum (of money, in cryptocurrency) will be transferred to you.
IF you transfer a certain amount of digital assets (cryptocurrency, for example, ether, bitcoin), THEN the A object will be transferred to you.
IF I finish the work, THEN the digital assets mentioned in the contract will be transferred to me.
Note: The WHEN constraint can be added to include the time factor in the smart contracts. It can be seen that these smart contracts help set conditions that have to be fulfilled for the terms of the contract agreement to be executed. There is no limit on how much IF or THEN you can include in your intelligent contract.

Identify Agreement: Multiple parties identify the cooperative opportunity and desired outcomes and agreements could include business processes, asset swaps, etc.
Set conditions: Smart contracts could be initiated by parties themselves or when certain conditions are met like financial market indices, events like GPS locations, etc.
Code business logic: A computer program is written that will be executed automatically when the conditional parameters are met.
Encryption and blockchain technology: Encryption provides secure authentication and transfer of messages between parties relating to smart contracts.
Execution and processing: In blockchain iteration, whenever consensus is reached between the parties regarding authentication and verification then the code is executed and the outcomes are memorialized for compliance and verification.
Network updates: After smart contracts are executed, all the nodes on the network update their ledger to reflect the new state. Once the record is posted and verified on the blockchain network, it cannot be modified, it is in append mode only.
Applications of Smart Contracts
Real Estate: Reduce money paid to the middleman and distribute between the parties actually involved. For example, a smart contract to transfer ownership of an apartment once a certain amount of resources have been transferred to the seller’s account(or wallet).
Vehicle ownership: A smart contract can be deployed in a blockchain that keeps track of vehicle maintenance and ownership. The smart contract can, for example, enforce vehicle maintenance service every six months; failure of which will lead to suspension of driving license.
Music Industry: The music industry could record the ownership of music in a blockchain. A smart contract can be embedded in the blockchain and royalties can be credited to the owner’s account when the song is used for commercial purposes. It can also work in resolving ownership disputes.
Government elections: Once the votes are logged in the blockchain, it would be very hard to decrypt the voter address and modify the vote leading to more confidence against the ill practices.
Management: The blockchain application in management can streamline and automate many decisions that are taken late or deferred. Every decision is transparent and available to any party who has the authority(an application on the private blockchain). For example, a smart contract can be deployed to trigger the supply of raw materials when 10 tonnes of plastic bags are produced.
Healthcare: Automating healthcare payment processes using smart contracts can prevent fraud. Every treatment is registered on the ledger and in the end, the smart contract can calculate the sum of all the transactions. The patient can’t be discharged from the hospital until the bill has been paid and can be coded in the smart contract.
Example Use cases:

Smart contracts provide utility to other contracts. For example, consider a smart contract that transfers funds to party A after 10 days. After 10 days, the above-mentioned smart contract will execute another smart contract which checks if the required funds are available at the source account(let’s say party B).
They facilitate the implementation of ‘multi-signature’ accounts, in which the assets are transferred only when a certain percentage of people agree to do so
Smart contracts can map legal obligations into an automated process.
If smart contracts are implemented correctly, can provide a greater degree of contractual security.

==========================================================================================

These two Solidity contracts are examples of smart contracts that simulate a simple bank-like system on the Ethereum blockchain. Let's break down each of them:

First Contract: Bank

This contract is named "Bank" and manages accounts and balances for Ethereum addresses. It has the following functionalities:

mapping(address=>uint) private balances: This is a private state variable that maps Ethereum addresses to their corresponding balances. It keeps track of the balance of each address.

function getBalance() public view returns (uint): This is a public function that allows an address to query their account balance. It returns the balance associated with the sender's address.

function deposit(uint amount) public payable: This function is used to deposit funds into the bank. It takes an amount as an argument and is marked as "payable" to accept Ether. It adds the deposited amount to the sender's balance.

function withdraw(uint amount) public payable: This function allows an address to withdraw funds from their account. It checks if the requested amount is less than or equal to the sender's balance and, if so, deducts the amount and transfers it to the sender's address.

Second Contract: SimpleBank

This contract is also a basic bank-like system with some additional features:

uint8 private clientCount: A private variable to keep track of the number of clients enrolled in the bank.

mapping (address => uint) private balances: A private mapping to associate addresses with their balances.

address public owner: A public variable to store the address of the contract owner.

event LogDepositMade(address indexed accountAddress, uint amount): An event that logs when a deposit is made. It includes the account address and the deposit amount.

constructor() public payable: The constructor initializes the contract, and it is marked as "payable" to accept an initial funding of 30 Ether when deploying the contract. The contract owner is set to the sender, and the client count is initialized to 0.

function enroll() public returns (uint): This function allows customers to enroll in the bank. The first three clients receive a reward of 10 Ether. It checks if the client count is less than 3 and, if so, increases the count and sets their balance to 10 Ether.

function deposit() public payable returns (uint): This function allows clients to deposit Ether into their accounts. It increases their balance and logs the deposit event.

function withdraw(uint withdrawAmount) public returns (uint remainingBal): Clients can use this function to withdraw Ether from their accounts. It checks if the requested withdrawal amount is less than or equal to the client's balance, deducts the amount, and transfers it to the client's address.

function balance() public view returns (uint): A read-only function that allows clients to check their account balance.

function depositsBalance() public view returns (uint): This function returns the balance of the Simple Bank contract itself.

These contracts demonstrate basic banking functionality on the Ethereum blockchain, allowing clients to enroll, deposit, withdraw, and check their balances. The second contract also has an initial funding requirement for deploying the contract and rewards the first three clients.

====================================================================

This Solidity code defines two contracts, `TestPayable` and `StudentRegister`, each with its own set of functions and functionality. Let's go through each of them:

**Contract `TestPayable`**

This contract is primarily used for testing the behavior of payable functions and fallback functions in Solidity. It has the following key components:

1. `uint x;` and `uint y;`: Two state variables to store integers `x` and `y`.

2. `fallback() external payable`: The fallback function is executed when the contract receives a message with non-empty `calldata`. It's marked as `payable` because it can receive Ether. This function sets the `x` variable to 1 and `y` to the value of Ether sent along with the message.

3. `receive() external payable`: The receive function is executed when the contract receives plain Ether transfers (calls with empty `calldata`). This function sets the `x` variable to 2 and `y` to the value of Ether sent.

**Contract `StudentRegister`**

This contract represents a student registration system with the following features:

1. `mapping(uint => Student) private students`: A mapping that associates student IDs with their corresponding `Student` structures. It's private, meaning only the contract can access it.

2. `address public owner`: A public variable to store the address of the contract owner.

3. `constructor() public payable`: The constructor initializes the contract and sets the contract's owner to the sender. It's also marked as `payable`, which means an initial funding can be sent when deploying the contract.

4. `modifier onlyOwner`: A custom modifier that restricts access to certain functions to the owner of the contract.

5. `struct Student`: A data structure representing a student, which includes fields for student ID, name, an array of marks, percentage, and a boolean flag to check if the student exists.

6. `function register(uint studentId, string memory name, uint[] memory marks)`: This function allows the contract owner to register a new student. It checks if the student with the given ID already exists and verifies that there are exactly three marks provided. If not, it calculates the percentage and stores the student's data.

7. `function getStudentDetails(uint studentId)`: This function allows anyone to retrieve student details given a student ID. It checks if the student exists and returns the relevant information.

8. `function getArraySum(uint[] memory array)`: A private utility function to calculate the sum of an array of integers.

9. `function callTestPayable(TestPayable test)`: This function is used to interact with the `TestPayable` contract. It demonstrates how to use low-level calls to the `TestPayable` contract's functions and send Ether to it, affecting the `x` and `y` variables in the `TestPayable` contract.

In summary, the `TestPayable` contract is used for testing the behavior of payable functions and fallback functions, while the `StudentRegister` contract allows the owner to register and retrieve student information in a secure manner. It also includes a custom modifier for access control.

===============================================================================================================================

Contract in Solidity is similar to a Class in C++. A Contract have following properties.

Constructor − A special function declared with constructor keyword which will be executed once per contract and is invoked when a contract is created.

State Variables − Variables per Contract to store the state of the contract.

Functions − Functions per Contract which can modify the state variables to alter the state of a contract.

Visibility Quantifiers
Following are various visibility quantifiers for functions/state variables of a contract.

external − External functions are meant to be called by other contracts. They cannot be used for internal call. To call external function within contract this.function_name() call is required. State variables cannot be marked as external.

public − Public functions/ Variables can be used both externally and internally. For public state variable, Solidity automatically creates a getter function.

internal − Internal functions/ Variables can only be used internally or by derived contracts.

private − Private functions/ Variables can only be used internally and not even by derived contracts.

Value Types
Solidity offers the programmer a rich assortment of built-in as well as user defined data types. Following table lists down seven basic C++ data types −

Type	Keyword	Values
Boolean	bool	true/false
Integer	int/uint	Signed and unsigned integers of varying sizes.
Integer	int8 to int256	Signed int from 8 bits to 256 bits. int256 is the same as int.
Integer	uint8 to uint256	Unsigned int from 8 bits to 256 bits. uint256 is the same as uint.

address
address holds the 20 byte value representing the size of an Ethereum address. An address can be used to get the balance using .balance method and can be used to transfer balance to another address using .transfer method.

Solidity supports three types of variables.

State Variables − Variables whose values are permanently stored in a contract storage.

Local Variables − Variables whose values are present till function is executing.

Global Variables − Special variables exists in the global namespace used to get information about the blockchain.

Solidity is a statically typed language, which means that the state or local variable type needs to be specified during declaration. Each declared variable always have a default value based on its type. There is no concept of "undefined" or "null".

State Variable
Variables whose values are permanently stored in a contract storage.

pragma solidity ^0.5.0;
contract SolidityTest {
   uint storedData;      // State variable
   constructor() public {
      storedData = 10;   // Using State variable
   }
}

Solidity supports String literal using both double quote (") and single quote ('). It provides string as a data type to declare a variable of type String.

pragma solidity ^0.5.0;

contract SolidityTest {
   string data = "test";
}